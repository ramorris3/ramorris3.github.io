<!doctype html><html lang=en-us data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Make-it Monday: Rogueslide Devlog #4 - Big Ideas for Little Games</title><meta name=description content="Game programming patterns for small, independent teams."><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><script src=https://kit.fontawesome.com/acfeb685d1.js crossorigin=anonymous></script><link rel=stylesheet href=https://littlegames.dev/css/style.1d8233f454bf6bbf46abed7023dbbba557fc4af5f1e39de066ac496c94409622.css integrity="sha256-HYIz9FS/a79Gq+1wI9u7pVf8SvXx453gZqxJbJRAliI="><meta property="og:title" content="Make-it Monday: Rogueslide Devlog #4"><meta property="og:description" content="This week in Rogueslide: the dungeon! Also, how I make enemy spawn frequencies editable with a code-free developer UI."><meta property="og:type" content="article"><meta property="og:url" content="https://littlegames.dev/posts/rs-devlog/4-dungeon/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-12T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Make-it Monday: Rogueslide Devlog #4"><meta name=twitter:description content="This week in Rogueslide: the dungeon! Also, how I make enemy spawn frequencies editable with a code-free developer UI."><link href=//cdn-images.mailchimp.com/embedcode/slim-10_7.css rel=stylesheet type=text/css><style type=text/css>#mc_embed_signup{background:#fff;clear:left;font:14px Helvetica,Arial,sans-serif}#mc_embed_signup form{padding-left:0}</style><link rel=stylesheet href=https://littlegames.dev/css/custom.css></head><body><a class=skip-main href=#main>Skip to main content</a><div class=container><header class=common-header><h1 class=site-title><a href=/><i class="fas fa-gamepad"></i> Big Ideas for Little Games</a></h1><nav><a href=https://littlegames.dev/ title>Posts</a>
<a href=https://littlegames.dev/tags/ title>Tags</a>
<a href=https://littlegames.dev/archive/ title>Archive</a>
<a href=https://littlegames.dev/about/ title>About</a></nav></header><main id=main tabindex=-1><article class="post h-entry"><header class=post-header><h1 class="p-name post-title">Make-it Monday: Rogueslide Devlog #4</h1></header><div class="content e-content"><p>Rogueslide is still in the &ldquo;make stuff&rdquo; section of its development lifecycle, meaning my work is mostly spent adding enemy tiles these days. However, most of these enemies were already implemented before the massive <a href=/posts/rs-devlog/1-modals>UI refactor</a>. This means progress has been (mostly) very quick in adding all those tiles, because I&rsquo;m solving problems that I&rsquo;ve already solved before.</p><p>As a result, in one weekend I was able to add enough enemies to populate the entire second area of the game: the dungeon!</p><h2 id=this-week-in-rogueslide-the-dungeon>This week in Rogueslide: The Dungeon</h2><p>Rogueslide&rsquo;s main game mode takes you through three areas, each with 3 floors: the forest, the dungeon, and the volcano. In the previous weeks, I&rsquo;ve focused on developing tiles for the forest area. With <a href=/posts/rs-devlog/3-spiders>the spider enemy</a> completed, I&rsquo;ve been able to move on to the dungeon.</p><p><figure><img src=/rs-devlog/4-dungeon/dungeon.gif alt="Animated GIF of dungeon level in rogueslide"><figcaption>ðŸŽµ Spooky scary skeletons send shivers down your spine. ðŸŽµ</figcaption></figure></p><p>If the goblin was the core enemy of the forest, the dungeon&rsquo;s bread-and-butter enemy type is the skeleton. It&rsquo;s fitting &ndash; what&rsquo;s a good dungeon crawler without a skeleton enemy?</p><h2 id=raising-the-dead>Raising The Dead</h2><p>Skeletons in Rogueslide come in two flavors: normal and archer (ranged). I&rsquo;ll talk more about the archers below.</p><p>The main gimmick of the skeleton tile (normal and archer) is that when it dies, it doesn&rsquo;t just disappear like the other tiles do. It turns into a &ldquo;pile of bones&rdquo; tile that just sits on the board.</p><p>These pile-o'-bones tiles don&rsquo;t slide anywhere, and so they can&rsquo;t hurt other enemies. They just sit in their place like rock tiles. Enemies can damage and clear them, and so can you. But if nothing clears out the pile-o'-bones within 5 turns, it&rsquo;ll reanimate into a skeleton with full health.</p><p><figure><img src=/rs-devlog/4-dungeon/skelly-death.gif alt="Animated GIF of skeleton dying and turning into a pile of bones"><figcaption>It wouldn't be a proper dungeon without piles of bones that reanimate on their own.</figcaption></figure></p><p><figure><img src=/rs-devlog/4-dungeon/skelly-reanimate.gif alt="Animated GIF of skeleton bone pile returning to full health as a skeleton"><figcaption>IT'S ALIVE.</figcaption></figure></p><p>If you&rsquo;ve been following this devlog, then you&rsquo;re aware of how I&rsquo;m using hooks to override core enemy behavior by &ldquo;plugging in&rdquo; to certain tile events. And you can probably guess which hook I&rsquo;m using here. Here&rsquo;s some simplified code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#75715e>// in the skelly class
</span><span style=color:#75715e></span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onDie</span>() {
  <span style=color:#66d9ef>val</span> bones = BonePileTile()
  board.placeTile(bones, <span style=color:#66d9ef>this</span>.tx, <span style=color:#66d9ef>this</span>.ty)
  screen.effects.fadeEffect(<span style=color:#e6db74>&#34;dust&#34;</span>, centerX, centerY)
  <span style=color:#66d9ef>super</span>.onDie()
}
</code></pre></div><p>When the skelly dies it simply creates a pile-o'-bones. The bone pile&rsquo;s <code>baseMove</code> stat is 0, so it will never slide, and its <code>baseAttack</code> is also 0, so it would never hurt anything even if it did slide. Its HP is 3, and when it dies, it just disappears like a normal enemy tile. But it has a special timer that I update every turn using the <code>onPreSlide</code> hook:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#75715e>// in the bone pile tile class
</span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> countdown = <span style=color:#ae81ff>5</span>

<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onPreSlide</span>(direction: Direction) {
    countdown<span style=color:#f92672>--</span>
    <span style=color:#66d9ef>super</span>.onPreSlide(direction)
}

<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onPostSlide</span>(direction: Direction) {
    <span style=color:#66d9ef>if</span> (countdown <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
        removeFromGame()
        <span style=color:#66d9ef>val</span> skelly = SkeletonTile(screen, skellyName)
        board.placeTile(skelly, <span style=color:#66d9ef>this</span>.tx, <span style=color:#66d9ef>this</span>.ty)
        screen.effects.fadeEffect(<span style=color:#e6db74>&#34;dust&#34;</span>, centerX, centerY)
    }
    <span style=color:#66d9ef>super</span>.onPostSlide(direction)
}
</code></pre></div><p>Why not just use <code>onPostSlide</code> to decrement the counter <em>and</em> check if it&rsquo;s done? Because I don&rsquo;t want the <code>onPostSlide</code> logic to run and decrement the counter on the same turn that this tile spawns.</p><h2 id=arrows-for-archers>Arrows For Archers</h2><p>The archer enemies behave a bit differently than most tiles. First of all, they don&rsquo;t slide like most other tiles &ndash; they only move one space at a time, like the spider. Second, they have a ranged attack in the form of an arrow.</p><p>This ranged arrow attack presented a few special problems:</p><ol><li>We need to scan all tile positions &ldquo;in front of&rdquo; the skeleton to see who to attack, instead of just waiting for a collision to happen.</li><li>We need to fire an actual arrow projectile so the player can visually read what&rsquo;s happening.</li><li>We need to wait for that arrow to &ldquo;hit&rdquo; the target before we resolve the attack, otherwise the &ldquo;-1&rdquo; damage UI on the tile will show up early, and things will look weird.</li><li>We need to fire an arrow projectile even if the attack doesn&rsquo;t resolve. For example, the skeleton still fires its arrow at rocks, but the rock isn&rsquo;t damaged (enemies don&rsquo;t damage rocks unless they are &ldquo;massive&rdquo;, like the cyclops).</li></ol><p>To solve these problems:</p><ol><li>I overrode the <code>onCollide</code> method in the skeleton so that it never handles any attack/damage logic there, like most tiles do. This is because the <code>onCollide</code> hook only happens when a tile actually bumps into another tile, and the skeleton archer will often be firing an arrow at something multiple tiles away.</li><li>I overrode the <code>onPostSlide</code> method to scan for the archer&rsquo;s target.</li><li>I treated the arrows like any other poolable effects by including a special <code>ProjectileEffect</code> class in my <code>EffectManager</code>. (I&rsquo;ll do a post soon on my custom <code>EffectManager</code> class that I always use for animated particles.) Effects are just visuals, and they are completely unaware of attack/damage logic. This means that even if there&rsquo;s no tile targeted by the skeleton, I can still fire a <code>ProjectileEffect</code> and just have it harmlessly stick into the &ldquo;wall&rdquo; on the edge of the game board.</li><li>I used <a href=/posts/directional-foreach>higher-order functions</a> to add an optional <code>callback</code> to the <code>ProjectileEffect</code>, and within that callback is where the attack/damage logic resolves, if a tile was targeted.</li></ol><p>Here&rsquo;s the end result:</p><p><figure><img src=/rs-devlog/4-dungeon/skelly-arrow.gif alt="Animated GIF of skeleton tile gameplay"><figcaption>The arrow still flies into the rock and wall, but the skelly only resolves an attack and deals damage when it fires the arrow at the player (or another enemy).</figcaption></figure></p><h2 id=custom-dev-tools-spawn-frequencies>Custom Dev-Tools: Spawn Frequencies</h2><p>If the whole board was full of only one predictable enemy, or lots of enemies with different stats that all behave the same, then gameplay would feel pretty bland. This is why we design each area of Rogueslide to have one straightforward enemy, and then we design around that enemy with some other more complex enemies.</p><p>Here&rsquo;s an example: Skeletons are a bit easy to handle on their own, but their bone piles clutter up the board and slow you down. If that was your only enemy type, clearing the board would feel tedious. So we have a cyclops tile that makes this situation more dynamic. The cyclops has double the health of a skeleton, and it deals a whopping 3 damage (equal to your starting HP) to anything and everything in its way. However the cyclops only moves 1 tile at a time, so it&rsquo;s easy enough to avoid it as long as you don&rsquo;t let yourself get cornered.</p><p>This leads to interesting gameplay decisions in the dungeon area. While playtesting, I found myself corralling cyclops tiles, using their strength to my advantage to clear out the board. It felt fun and engaging to work to line up the skeletons all in a row, slide them into each other until they were all bone piles, and then have the cyclops stomp out each bone pile in a single turn. It also felt engaging and fun when my plan backfired, and I found myself surrounded by enemies &ndash; one of which being the cyclops that I had preserved to do my bone-crushing.</p><p><a href=/posts/rs-devlog/3-spiders>As I mentioned last week</a>, the guiding design philosophy is to keep it simple enough to feel casual, but complex enough to be engaging. We want enough of the weird enemies to make the game spicy, but not so many that you can&rsquo;t make gameplay decisions somewhat intuitively.</p><p>You can imagine that walking this fine line requires lots of playtesting, and lots of iteration when it comes to the spawn frequencies of each tile. And that iteration can move really quickly when our designer doesn&rsquo;t have to tweak hardcoded values in our code and rebuild the project each time a tweak needs to be made.</p><p>So with that in mind, I created a simple &ldquo;developer tools&rdquo; interface in the title screen&rsquo;s option menu. This interface shows a slider UI widget for each enemy that could possibly spawn in the given area. That slider then determines the percentage chance that the given enemy will spawn on that floor within that area.</p><p><figure><img src=/rs-devlog/4-dungeon/spawn-sliders.gif alt="Animated GIF of spawn-frequency sliders in the dev tools menu."><figcaption>It's not the prettiest UI in the game, but it doesn't have to be.</figcaption></figure></p><p>Behind the scenes, I have a super-simple data class that holds these spawn values in a list. The developer tools menu loads up an instance of this data class in memory, and every time a slider value changes, it saves the modified instance to a json file stored in my assets folder. The <code>Spawner</code> class that loads enemies each turn just looks at those values to determine which enemy to spawn.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#75715e>// spawn data classes for json serialization
</span><span style=color:#75715e></span><span style=color:#a6e22e>@Serializable</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TileSpawnProbability</span>(<span style=color:#66d9ef>val</span> classname: String, <span style=color:#66d9ef>var</span> probability: Float = <span style=color:#ae81ff>0f</span>) {
    <span style=color:#66d9ef>val</span> name: String
        <span style=color:#66d9ef>get</span>() = classname.split(<span style=color:#e6db74>&#34;.&#34;</span>).last()
}

<span style=color:#a6e22e>@Serializable</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SpawnData</span> {
    <span style=color:#66d9ef>val</span> forestProbs: List&lt;List&lt;TileSpawnProbability&gt;&gt; = listOf()
    <span style=color:#66d9ef>val</span> dungeonProbs: List&lt;List&lt;TileSpawnProbability&gt;&gt; = listOf()
    <span style=color:#66d9ef>val</span> volcanoProbs: List&lt;List&lt;TileSpawnProbability&gt;&gt; = listOf()
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#75715e>// dev tools menu code that generically sets up sliders for each spawn probability 
</span><span style=color:#75715e></span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>initSpawnSlider</span>(prob: TileSpawnProbability) {
    <span style=color:#66d9ef>val</span> slider = Slider(<span style=color:#ae81ff>0f</span>, <span style=color:#ae81ff>100f</span>, <span style=color:#ae81ff>1f</span>, <span style=color:#66d9ef>false</span>, skin, <span style=color:#e6db74>&#34;options-slider&#34;</span>)
    slider.value = prob.probability
    <span style=color:#66d9ef>val</span> sliderLabel = Label(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${prob.name}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>${prob.probability}</span><span style=color:#e6db74>%&#34;</span>, skin, <span style=color:#e6db74>&#34;white-64&#34;</span>)
    slider.addListener(<span style=color:#66d9ef>object</span>: ChangeListener() {
        <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>changed</span>(event: ChangeEvent?, actor: Actor?) {
            <span style=color:#66d9ef>if</span> (event <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
                prob.probability = slider.value
                SpawnService.save()
                sliderLabel.setText(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${prob.name}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>${prob.probability}</span><span style=color:#e6db74>%&#34;</span>)
            }
        }
    })
    spawnTable.add(sliderLabel).left().padLeft(tileWidth / <span style=color:#ae81ff>2f</span>).padBottom(settingsLabelPad)
    spawnTable.row().padBottom(settingsLinePad)
    spawnTable.add(slider).growX().padLeft(tileWidth / <span style=color:#ae81ff>2f</span>).padRight(tileWidth / <span style=color:#ae81ff>2f</span>)
    spawnTable.row()
}

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>initAreaSpawnSliders</span>(areaName: String, areaLevelProbs: List&lt;List&lt;TileSpawnProbability&gt;&gt;) {
    areaLevelProbs.forEachIndexed { i, level <span style=color:#f92672>-&gt;</span>
        <span style=color:#66d9ef>val</span> levelLabel = Label(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$areaName</span><span style=color:#e6db74> </span><span style=color:#e6db74>${i + 1}</span><span style=color:#e6db74>&#34;</span>, skin, <span style=color:#e6db74>&#34;menuTitle&#34;</span>)
        spawnTable.add(levelLabel).center().padBottom(settingsLinePad)
        spawnTable.row()
        level.forEach { tileProb <span style=color:#f92672>-&gt;</span> initSpawnSlider(tileProb) }
    }
}

initAreaSpawnSliders(<span style=color:#e6db74>&#34;Forest&#34;</span>, SpawnService.<span style=color:#66d9ef>data</span>.forestProbs)
initAreaSpawnSliders(<span style=color:#e6db74>&#34;Dungeon&#34;</span>, SpawnService.<span style=color:#66d9ef>data</span>.dungeonProbs)
initAreaSpawnSliders(<span style=color:#e6db74>&#34;Volcano&#34;</span>, SpawnService.<span style=color:#66d9ef>data</span>.volcanoProbs)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// serialized json in assets folder
</span><span style=color:#75715e></span>{
  <span style=color:#e6db74>&#34;forestProbs&#34;</span><span style=color:#f92672>:</span> [
    [
      {
        <span style=color:#e6db74>&#34;classname&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;com.beepyeah.rogueslide.tiles.GoblinTile&#34;</span>,
        <span style=color:#e6db74>&#34;probability&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>75.0</span>
      },
      {
        <span style=color:#e6db74>&#34;classname&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;com.beepyeah.rogueslide.tiles.VineTile&#34;</span>,
        <span style=color:#e6db74>&#34;probability&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2.0</span>
      },
      {
        <span style=color:#e6db74>&#34;classname&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;com.beepyeah.rogueslide.tiles.SpiderTile&#34;</span>,
        <span style=color:#e6db74>&#34;probability&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>7.0</span>
      },
      {
        <span style=color:#e6db74>&#34;classname&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;com.beepyeah.rogueslide.tiles.SlimeTile&#34;</span>,
        <span style=color:#e6db74>&#34;probability&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>21.0</span>
      }
    ],
  ],
  <span style=color:#e6db74>&#34;dungeonProbs&#34;</span><span style=color:#f92672>:</span> [...],
  <span style=color:#e6db74>&#34;volcanoProbs&#34;</span><span style=color:#f92672>:</span> [...]
}
</code></pre></div><p>That&rsquo;s the idea in a nutshell. There&rsquo;s a bit more going on here (kotlinx serialization, a singleton spawner service, and even some class reflection), but I&rsquo;ll spare the details.</p><h2 id=see-ya>See Ya</h2><p>That wraps up this week&rsquo;s Rogueslide update! Once again, thanks so much for joining me. Stick around for more updates, and as always, happy coding.</p></div><div class=post-info><div class="post-date dt-published">2021-04-12</div><a class="post-hidden-url u-url" href=https://littlegames.dev/posts/rs-devlog/4-dungeon/>https://littlegames.dev/posts/rs-devlog/4-dungeon/</a>
<a href=https://littlegames.dev class="p-name p-author post-hidden-author h-card" rel=me>Alex Morris</a><div class=post-taxonomies><ul class=post-tags><li><a href=https://littlegames.dev/tags/rogueslide>#rogueslide</a></li><li><a href=https://littlegames.dev/tags/devlog>#devlog</a></li><li><a href=https://littlegames.dev/tags/make-it-monday>#make it monday</a></li><li><a href=https://littlegames.dev/tags/ui>#ui</a></li><li><a href=https://littlegames.dev/tags/kotlin>#kotlin</a></li></ul></div></div></article><div class="pagination post-pagination"><div class="left pagination-item"><a href=/posts/rs-devlog/5-volcano/>Make-it...Tuesday? (Rogueslide Devlog #5)</a></div><div class="right pagination-item"><a href=/posts/rs-devlog/3-spiders/>Make-it Monday: Rogueslide Devlog #3</a></div></div></main><footer class=common-footer><div id=mc_embed_signup><form action="https://dev.us1.list-manage.com/subscribe/post?u=515a1fe97dd6c90c23716c5b0&id=8a228e0da4" method=post id=mc-embedded-subscribe-form name=mc-embedded-subscribe-form class=validate target=_blank novalidate><div id=mc_embed_signup_scroll><input type=email name=EMAIL class=email id=mce-EMAIL placeholder="Email address" required><div style=position:absolute;left:-5000px aria-hidden=true><input type=text name=b_515a1fe97dd6c90c23716c5b0_8a228e0da4 tabindex=-1></div><div class=clear><input type=submit value=Subscribe name=subscribe id=mc-embedded-subscribe class=button></div></div></form></div><div class=common-footer-bottom><div class=copyright><p>Â© Alex Morris, 2021<br><a href=https://twitter.com/ramorris_3 target=_blank><i class="fab fa-twitter-square"></i> @ramorris_3</a><br>Powered by <a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>, theme <a target=_blank rel="noopener noreferrer" href=https://github.com/mitrichius/hugo-theme-anubis>Anubis</a>.<br></p></div></div><p class="h-card vcard"><a href=https://littlegames.dev class="p-name u-url url fn" rel=me>Alex Morris</a></p></footer></div></body></html>