<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sample project on Big Ideas for Little Games</title><link>https://littlegames.dev/tags/sample-project/</link><description>Big Ideas for Little Games (sample project)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 17 Mar 2021 15:08:48 -0600</lastBuildDate><atom:link href="https://littlegames.dev/tags/sample-project/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlin High-Order Functions: directionalForEach</title><link>https://littlegames.dev/posts/directional-foreach/</link><pubDate>Wed, 17 Mar 2021 15:08:48 -0600</pubDate><guid>https://littlegames.dev/posts/directional-foreach/</guid><description>&lt;p>When you have a tile-based game, it&amp;rsquo;s common to store actors in a double-nested list, and then have each actor perform an action by iterating over the list. But what if you don&amp;rsquo;t always want your actors to act in left-to-right, top-down order? We&amp;rsquo;re going to use &lt;a href="https://kotlinlang.org/docs/lambdas.html">high-order functions in Kotlin&lt;/a> to avoid messy, duplicated code.&lt;/p>
&lt;h2 id="the-problem-slidey-tiles">The Problem: Slidey Tiles&lt;/h2>
&lt;p>Let&amp;rsquo;s look at a simple 2048-style puzzle game. The user gives directional input, and all the tiles on the board move based on that input.&lt;/p>
&lt;p>&lt;figure>
&lt;img src="https://littlegames.dev/directional-foreach/stars-example.gif" alt="Simple example of a common tile-sliding puzzle game">
&lt;figcaption>Our example project is like 2048 lite: stars don&amp;#39;t grow when they combine.&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>The simplest (or at least most intuitive) way to store these tiles in memory would be to create a 2d array with nullable entries. Assuming the tiles are all responsible for their own update and draw logic, it&amp;rsquo;s really easy to update every tile at once each frame:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// empty 2d array of nullable Tile objects
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> tiles = Array(numRows) { arrayOfNulls&amp;lt;Tile?&amp;gt;(numCols) }
&lt;span style="color:#75715e">// update all tiles
&lt;/span>&lt;span style="color:#75715e">&lt;/span>tiles.forEach { row &lt;span style="color:#f92672">-&amp;gt;&lt;/span> row.forEach { &lt;span style="color:#66d9ef">it&lt;/span>&lt;span style="color:#f92672">?.&lt;/span>update(delta) } }
&lt;span style="color:#75715e">// draw all tiles
&lt;/span>&lt;span style="color:#75715e">&lt;/span>tiles.forEach { row &lt;span style="color:#f92672">-&amp;gt;&lt;/span> row.forEach { &lt;span style="color:#66d9ef">it&lt;/span>&lt;span style="color:#f92672">?.&lt;/span>draw() } }
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This works out great when the order in which the tile does a thing doesn&amp;rsquo;t matter. But what about when the order &lt;em>does&lt;/em> matter? Look at this example of a game board, and let&amp;rsquo;s say the user tries to slide all the tiles down.&lt;/p>
&lt;p>&lt;figure>
&lt;img src="https://littlegames.dev/directional-foreach/board-state.png" alt="Example board state">
&lt;figcaption>If the user slides all the tiles down, what&amp;#39;s going to happen if we iterate through the tile objects from left to right, top to bottom in our code?&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Here, we need to iterate over every single tile, and move that tile downwards as far as it can go (until it collides with another tile, or hits the edge of the board). You might try to iterate like we did above:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// Bad
&lt;/span>&lt;span style="color:#75715e">&lt;/span>tiles.forEach { row &lt;span style="color:#f92672">-&amp;gt;&lt;/span> row.forEach { tile &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span>(!tile.atBottomOfBoard) {
&lt;span style="color:#66d9ef">val&lt;/span> nextTile = tile.nextTileBelow
&lt;span style="color:#66d9ef">if&lt;/span> (nextTile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
tile.collide(nextTile)
&lt;span style="color:#66d9ef">return&lt;/span>
}
tile.moveDown()
}
} }
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When you playtest, you&amp;rsquo;ll quickly see some problems with this: Number 1 on the top row can&amp;rsquo;t move down, because 3 is blocking it! And number 2 on the top row will stay put, because the 4&amp;rsquo;s beneath it haven&amp;rsquo;t slid down and combined yet. In more general terms, you need to slide each tile downwards by iterating from the bottom up instead of going top-to-bottom.&lt;/p>
&lt;h2 id="the-naive-approach-with-lots-of-duplicated-code">The Naive Approach With Lots Of Duplicated Code&lt;/h2>
&lt;p>So now you need to take that logic that slides a single tile and handle it for each direction. Let&amp;rsquo;s start with something like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">when&lt;/span> (dir) {
Direction.LEFT &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
&lt;span style="color:#66d9ef">if&lt;/span> (tile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;span style="color:#66d9ef">while&lt;/span>(!tile.atLeftOfBoard) {
&lt;span style="color:#66d9ef">val&lt;/span> nextTile = tile.nextTileLeft
&lt;span style="color:#66d9ef">if&lt;/span> (nextTile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
tile.collide(nextTile)
&lt;span style="color:#66d9ef">return&lt;/span>
}
tile.moveLeft()
}
}
}
}
}
Direction.RIGHT &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(cols - &lt;span style="color:#ae81ff">1&lt;/span> downTo &lt;span style="color:#ae81ff">0&lt;/span>).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
&lt;span style="color:#66d9ef">if&lt;/span> (tile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;span style="color:#66d9ef">while&lt;/span>(!tile.atRightOfBoard) {
&lt;span style="color:#66d9ef">val&lt;/span> nextTile = tile.nextTileRight
&lt;span style="color:#66d9ef">if&lt;/span> (nextTile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
tile.collide(nextTile)
&lt;span style="color:#66d9ef">return&lt;/span>
}
tile.moveRight()
}
}
}
}
}
Direction.DOWN &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
&lt;span style="color:#66d9ef">if&lt;/span> (tile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;span style="color:#66d9ef">while&lt;/span>(!tile.atBottomOfBoard) {
&lt;span style="color:#66d9ef">val&lt;/span> nextTile = tile.nextTileDown
&lt;span style="color:#66d9ef">if&lt;/span> (nextTile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
tile.collide(nextTile)
&lt;span style="color:#66d9ef">return&lt;/span>
}
tile.moveDown()
}
}
}
}
}
Direction.UP &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(rows - &lt;span style="color:#ae81ff">1&lt;/span> downTo &lt;span style="color:#ae81ff">0&lt;/span>).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
&lt;span style="color:#66d9ef">if&lt;/span> (tile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;span style="color:#66d9ef">while&lt;/span>(!tile.atTopOfBoard) {
&lt;span style="color:#66d9ef">val&lt;/span> nextTile = tile.nextTileUp
&lt;span style="color:#66d9ef">if&lt;/span> (nextTile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
tile.collide(nextTile)
&lt;span style="color:#66d9ef">return&lt;/span>
}
tile.moveUp()
}
}
}
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Yikes. There are a lot of blocks of code that look &lt;em>very&lt;/em> similar, but just different enough to be hard to repeat. Also, the code here has been simplified quite a bit. In the actual &lt;a href="https://github.com/ramorris3/halcyon">example project&lt;/a>, there&amp;rsquo;s more that goes into tile sliding and collisions: increasing the player&amp;rsquo;s score and updating the UI accordingly, checking if the board is full (game over), etc. It goes without saying that your directional loops are going to get huge if you&amp;rsquo;re not careful.&lt;/p>
&lt;p>Let&amp;rsquo;s start by making tile slides/collisions generic, and then plopping that function in there.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#66d9ef">when&lt;/span> (dir) {
Direction.LEFT &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
tile&lt;span style="color:#f92672">?.&lt;/span>slide(dir)
}
}
}
Direction.RIGHT &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(cols - &lt;span style="color:#ae81ff">1&lt;/span> downTo &lt;span style="color:#ae81ff">0&lt;/span>).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
tile&lt;span style="color:#f92672">?.&lt;/span>slide(dir)
}
}
}
Direction.DOWN &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
tile&lt;span style="color:#f92672">?.&lt;/span>slide(dir)
}
}
}
Direction.UP &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(rows - &lt;span style="color:#ae81ff">1&lt;/span> downTo &lt;span style="color:#ae81ff">0&lt;/span>).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
tile&lt;span style="color:#f92672">?.&lt;/span>slide(dir)
}
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s much better, but you&amp;rsquo;ll find yourself repeating that big outer &lt;code>when(dir)&lt;/code> block any time you want to directionally iterate over tiles and do anything other than sliding the tiles.&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> If this feels like a contrived example, that&amp;rsquo;s because it is. But this was a very real, practical problem for &lt;a href="https://store.steampowered.com/app/1443100/Rogueslide/">my game Rogueslide&lt;/a>.&lt;/p>
&lt;p>&lt;figure>
&lt;img src="https://littlegames.dev/directional-foreach/rogueslide-example.gif" alt="Rogueslide demo gif">
&lt;figcaption>&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>In that game, slide logic is separated from collide logic. Even more difficult, tiles each behave differently depending on their type, but all of their behaviors are impacted by the slide direction. If each tile has methods that all need to be called in a directional order, then we&amp;rsquo;re looking at tons of unnecessary &lt;code>when(dir)&lt;/code> blocks scattered throughout our code.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// Bad example with tons of repeated directional double-loops
&lt;/span>&lt;span style="color:#75715e">&lt;/span>def slideTiles(dir: Direction) {
&lt;span style="color:#66d9ef">when&lt;/span>(dir) {
Direction.LEFT &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
tile&lt;span style="color:#f92672">?.&lt;/span>slide(dir)
}
}
},
&lt;span style="color:#75715e">// ... and for the other 3 directions
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
def collideTiles(dir: Direction) {
&lt;span style="color:#66d9ef">when&lt;/span>(dir) {
Direction.LEFT &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
tile&lt;span style="color:#f92672">?.&lt;/span>collide(dir)
}
}
},
&lt;span style="color:#75715e">// ... and for the other 3 directions
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
def preSlide(dir: Direction) {
&lt;span style="color:#66d9ef">when&lt;/span>(dir) {
Direction.LEFT &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
tile&lt;span style="color:#f92672">?.&lt;/span>preSlide(dir)
}
}
},
&lt;span style="color:#75715e">// ... and for the other 3 directions
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
def postSlide(dir: Direction) {
&lt;span style="color:#66d9ef">when&lt;/span>(dir) {
Direction.LEFT &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
tile&lt;span style="color:#f92672">?.&lt;/span>postSlide(dir)
}
}
},
&lt;span style="color:#75715e">// ... and for the other 3 directions
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You&amp;rsquo;ll find yourself doing a lot of copying/pasting if you follow this pattern.&lt;/p>
&lt;h2 id="the-dry-friendly-solution-high-order-functions-and-lambdas">The DRY-friendly Solution: High-order Functions and Lambdas&lt;/h2>
&lt;p>This is where &lt;a href="https://kotlinlang.org/docs/lambdas.html">high-order functions&lt;/a> become our friend. Higher-order functions are simply functions that take other functions (lambdas) as arguments. They&amp;rsquo;re very useful when we have some outer &amp;ldquo;wrapper&amp;rdquo; logic that doesn&amp;rsquo;t really care about what happens inside. If you&amp;rsquo;ve worked with promises in JavaScript, you&amp;rsquo;re probably pretty familiar with this concept.&lt;/p>
&lt;p>A great example of a higher-order function is Kotlin&amp;rsquo;s &lt;code>forEach&lt;/code> method, which we&amp;rsquo;ve already used extensively above. When you call &lt;code>forEach&lt;/code> on a list, you want to do something specific to each item in the list. But you don&amp;rsquo;t want to have to write the &amp;ldquo;wrapper&amp;rdquo; logic that loops through every item each time.&lt;/p>
&lt;p>We&amp;rsquo;re going to do a modified version of the &lt;code>forEach&lt;/code> method. This new method - which we&amp;rsquo;ll call &lt;code>directionalForEach&lt;/code> - will generalize two pieces of wrapper logic for us:&lt;/p>
&lt;ul>
&lt;li>Give us every non-empty tile in our 2d list of tiles&lt;/li>
&lt;li>Give them to us in the order we care about, depending on the directional input from the user.&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>directionalForEach&lt;/code> function will then take &lt;strong>another&lt;/strong> function - we&amp;rsquo;ll call it a &lt;code>callback&lt;/code> - as its argument. Remember, the directional loop doesn&amp;rsquo;t care what each tile does. It doesn&amp;rsquo;t care about what happens in the callback. It&amp;rsquo;s &lt;em>only&lt;/em> concerned with the order in which those tiles do the thing.&lt;/p>
&lt;p>If you&amp;rsquo;re getting lost in the lingo (functions on functions with functions), bear with me. This will make much more sense when you see it in action below:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="color:#75715e">// Now that this method is generalized, we only have to do this
&lt;/span>&lt;span style="color:#75715e">// directional looping logic once.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>def directionalForEach(dir: Direction, callback: ((d: Direction, t: tile) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit)) {
&lt;span style="color:#66d9ef">when&lt;/span>(dir) {
Direction.LEFT &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
(&lt;span style="color:#ae81ff">0&lt;/span> until rows).forEach { ty &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
(&lt;span style="color:#ae81ff">0&lt;/span> until cols).forEach { tx &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">val&lt;/span> tile = tiles[ty][tx]
&lt;span style="color:#66d9ef">if&lt;/span> (tile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
callback.invoke(dir, tile)
}
}
}
},
&lt;span style="color:#75715e">// ... and for the other 3 directions
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;span style="color:#75715e">// Now we can do all kinds of directionally-dependent things without
&lt;/span>&lt;span style="color:#75715e">// repeating the nasty when(dir) block
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> direction = getDirectionFromInput()
directionalForEach(direction) { dir, tile &lt;span style="color:#f92672">-&amp;gt;&lt;/span> tile.preSlide(dir) }
directionalForEach(direction) { dir, tile &lt;span style="color:#f92672">-&amp;gt;&lt;/span> tile.slide(dir) }
directionalForEach(direction) { dir, tile &lt;span style="color:#f92672">-&amp;gt;&lt;/span> tile.collide(dir) }
directionalForEach(direction) { dir, tile &lt;span style="color:#f92672">-&amp;gt;&lt;/span> tile.postSlide(dir) }
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is much cleaner, and becomes a lot more valuable as we add more directionally-dependent tile behaviors throughout our code. We only have to write the directional-loop logic once. Once that&amp;rsquo;s in place and generalized, we get to compartmentalize our tile logic into small, bite-sized functions that only care about the current tile, and the input direction.&lt;/p>
&lt;p>As an added bonus, &lt;a href="https://kotlinlang.org/docs/lambdas.html#passing-trailing-lambdas">Kotlin has syntactic sugar&lt;/a> where you can leave the lambda expression outside of the higher-order function&amp;rsquo;s parentheses if it&amp;rsquo;s the last argument. So that&amp;rsquo;s neat.&lt;/p>
&lt;h2 id="overview-and-example-project">Overview and Example Project&lt;/h2>
&lt;p>To wrap things up, here are some takeaways:&lt;/p>
&lt;ul>
&lt;li>A higher-order function is a function that takes functions as parameters, or returns a function.&lt;/li>
&lt;li>High-order functions are useful when you have some &amp;ldquo;wrapper&amp;rdquo; logic that doesn&amp;rsquo;t care about what happens inside.&lt;/li>
&lt;/ul>
&lt;p>Even though this article&amp;rsquo;s example was fairly contrived, I hope it helps you think of ways you can generalize your logic and reuse tedious bits of code. There are limitless use cases. To give you some ideas, here are some of the many places I&amp;rsquo;ve used high-order functions in my game code:&lt;/p>
&lt;ul>
&lt;li>A &lt;code>Collision&lt;/code> class with an local lambda variable called &lt;code>callback&lt;/code> that gets invoked whenever the collision happens.&lt;/li>
&lt;li>A &lt;code>Timer&lt;/code> utility class that plugs into the game&amp;rsquo;s core loop, decrements itself over time, and invokes a callback when it finishes.&lt;/li>
&lt;li>An optional &lt;code>animationEnd&lt;/code> lambda on a custom &lt;code>AnimationsManager&lt;/code> class that executes arbitrary logic whenever an animation finishes.&lt;/li>
&lt;/ul>
&lt;p>Thanks for tuning in. If you&amp;rsquo;re interested in looking at some source code, I&amp;rsquo;ve published a &lt;a href="">complete sample LibGDX project for this article to github&lt;/a>. (The &lt;code>directionalForEach&lt;/code> code lives in &lt;code>Board.kt&lt;/code>.)&lt;/p></description></item></channel></rss>